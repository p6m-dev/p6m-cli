// build.rs

use std::{io::Write, process::Command, str::from_utf8};

fn write_to(
    dir: impl AsRef<std::path::Path>,
    file_name: impl AsRef<std::ffi::OsStr>,
    args: std::fmt::Arguments,
) -> std::io::Result<()> {
    let dest = dir.as_ref().join(file_name.as_ref());
    let mut dest = std::fs::File::create(dest)?;
    dest.write_fmt(args)
}

fn generate_git_constants() -> std::io::Result<()> {
    let out_dir = if let Some(dir) = std::env::var_os("OUT_DIR") {
        dir
    } else {
        return Err(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "missing OUT_DIR environment variable",
        ));
    };

    let is_dirty_output = Command::new("git")
        .args(["status", "--porcelain"])
        .output()
        .expect("Failed to execute git status");
    let is_dirty = !is_dirty_output.stdout.is_empty();

    let commit_hash_output = Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .expect("Failed to execute command");
    let commit_hash = from_utf8(&commit_hash_output.stdout).expect("Invalid UTF-8");

    write_to(
        &out_dir,
        "version_constants.rs",
        format_args!(
"// Generated by build.rs

/// Git hash of the commit the binary is built from.
pub const GIT_COMMIT_HASH: &'static str = \"{commit_hash}\";

/// Flag which is set to true if the binary is built from a git directory that has uncommited changes.
pub const GIT_IS_DIRTY: bool = {is_dirty};
",
            commit_hash = commit_hash.trim(),
            is_dirty = is_dirty,
        ),
    )?;

    Ok(())
}

fn main() -> std::io::Result<()> {
    generate_git_constants()?;
    Ok(())
}
